# 스프링 부트와 AWS로 혼자 구현하는 웹 서비스

## 스프링 부트에서 테스트 코드 작성하기
테스트 코드를 작성함으로써 얻는 이점?
* 단위 테스트는 개발단계 초기에 문제를 발견하게 도와줍니다.
* 단위 테스트는 개발자가 나중에 코드를 리팩토링하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게   
  작동하는지 확인할 수 있습니다.(예, 회귀 테스트)
* 단위 테스트는 기능에 대한 불확실성을 감소시킬 수 있습니다.
* 단위 테스트는 시스템에 대한 실제 문서를 제공합니다. 즉, 단위 테스트 자체가 문서로 사용할 수 있습니다.

기존 개발방식
1. 코드를 작성하고
2. 프로그램(Tomcat)을 실행한 뒤
3. Postman과 같은 API 테스트 도구로 HTTP를 요청하고
4. 요청 결과를 System.out.println()으로 눈으로 검증하고
5. 결과가 다르면 다시 프로그램(Tomcat)을 중지하고 코드를 수정한다.

`기존방식에서 테스트코드를 작성하면 얻는 이점`   
2~5는 매번 코드를 수정할 때마다 반복해야한다. 톰캣 재시작은 수십초에서 1시간 이상 소요되지만 테스트 코드를 작성하면 이런문제가   해결된다.
System.out.println을 통해 눈으로 검증하지 않고 테스트 코드로 자동검증 할 수 있다.   
개발자가 만든 기능을 안전하게 보호해준다. A라는 기존 기능에 기본 기능을 비롯해 여러경우를 모두 테스트코드로 구현해놓았다면    
테스트 코드를 수행만 하면 문제를 초기에 찾을수 있다.   

`내장 WAS를 권장하는 이유`   
'언제 어디서나 같은 환경에서 스프링 부트를 배포할수 있기 때문이다.'


## 프로젝트에 Spring Data Jpa 적용하기
서로 지향하는 바가 다른 2개 영역(객체지향 프로그래밍 언어와 관계형 데이터베이스)을 중간에서 패러다임 일치 시켜주기 위한 기술

---
@NoArgsConstructor   
롬복의 어노테이션으로 기본생성자를 자동으로 추가해준다.   
@Builder   
해당 클래스의 빌더 패턴 클래스를 생성해준다. 생성자 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함   
---
@Entity   
테이블과 링크될 클래스   
@Id   
해당 테이블의 PK   
@GeneratedValue   
PK의 생성 규칙을 나타낸다. (GenerationType.IDENTITY 옵션 추가시 auto_increment)
@Column   
테이블의 칼럼을 나타내며 굳이 선언하지 않더라도 해당 클래스의 필드는 모두 컬럼이 된다.   
---
`Entity 클래스에서는 절대 Setter메소드를 만들지 않는다.`   

@Repository 추가할 필요 없으며 Entity 클래스와 기본 Entity Repository는 함께 위치해야 한다.   

